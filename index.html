<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Capture → Crop → OCR (one-shot)</title>
    <style>
      body {
        font-family: system-ui, Segoe UI, Roboto, Arial;
        margin: 14px;
        color: #111;
      }
      #controls {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-bottom: 10px;
      }
      button,
      input[type="file"],
      select {
        padding: 8px;
        border-radius: 6px;
        border: 1px solid #ccc;
        background: #fff;
      }
      #viewerWrap {
        position: relative;
        max-width: 820px;
      }
      #capturedImg {
        width: 100%;
        display: block;
        border: 1px solid #ddd;
        background: #222;
      }
      canvas#drawCanvas {
        position: absolute;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        pointer-events: auto;
      }
      #ocrResult {
        white-space: pre-wrap;
        background: #fff;
        border: 1px solid #eee;
        padding: 8px;
        margin-top: 8px;
        min-height: 40px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
      }
      th,
      td {
        border: 1px solid #ddd;
        padding: 6px;
        text-align: left;
        font-size: 13px;
      }
      td[contenteditable] {
        background: #fff;
      }
      #status {
        margin-top: 8px;
        color: #555;
      }
      .small {
        font-size: 13px;
        color: #666;
      }
    </style>
  </head>
  <body>
    <h2>Capture → Draw → Crop → OCR (one-shot flow)</h2>
    <div id="controls">
      <button id="openCamBtn">Open Camera</button>
      <button id="captureBtn" disabled>Capture</button>
      <input id="uploadFile" type="file" accept="image/*" />
      <select id="machineSelect">
        <option>ML1</option>
        <option>ML2</option>
        <option>ML3</option>
        <option>ML4</option>
        <option>ML5</option>
        <option>ML6</option>
        <option>ML7</option>
        <option>ML8</option>
      </select>
      <button id="cropOcrBtn" disabled>Crop & OCR</button>
      <button id="downloadCsv">Download CSV</button>
    </div>

    <div id="viewerWrap">
      <!-- Hidden video used only while camera open -->
      <video id="video" playsinline style="display: none"></video>

      <!-- captured image displayed here -->
      <img id="capturedImg" alt="Captured image will appear here" src="" />

      <!-- transparent canvas for drawing selection (size synced to image) -->
      <canvas id="drawCanvas"></canvas>
    </div>

    <div id="status">Status: idle</div>

    <h3>OCR (cropped) result</h3>
    <div
      id="ocrResult"
      contenteditable="true"
      placeholder="Cropped OCR text appears here"
    ></div>
    <div style="margin-top: 8px; display: flex; gap: 8px; align-items: center">
      <label class="small">Assign to:</label>
      <select id="assignField">
        <option value="downTime">Down Time</option>
        <option value="reason">Reason</option>
        <option value="occurrence">Occurrence</option>
        <option value="operator">Operator</option>
      </select>
      <button id="assignBtn">Assign & Save Row</button>
    </div>

    <h3>Saved rows</h3>
    <table id="dataTable">
      <thead>
        <tr>
          <th>Machine</th>
          <th>Down Time</th>
          <th>Reason</th>
          <th>Occurrence</th>
          <th>Operator</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>

    <script src="https://unpkg.com/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
    <script>
      // ---------- elements ----------
      const openCamBtn = document.getElementById("openCamBtn");
      const captureBtn = document.getElementById("captureBtn");
      const uploadFile = document.getElementById("uploadFile");
      const video = document.getElementById("video");
      const capturedImg = document.getElementById("capturedImg");
      const drawCanvas = document.getElementById("drawCanvas");
      const cropOcrBtn = document.getElementById("cropOcrBtn");
      const statusEl = document.getElementById("status");
      const ocrResult = document.getElementById("ocrResult");
      const assignField = document.getElementById("assignField");
      const assignBtn = document.getElementById("assignBtn");
      const machineSelect = document.getElementById("machineSelect");
      const tbody = document.getElementById("tbody");
      const downloadCsv = document.getElementById("downloadCsv");

      const DB_KEY = "downtime_rows_v2";
      function loadRows() {
        return JSON.parse(localStorage.getItem(DB_KEY) || "[]");
      }
      function saveRows(arr) {
        localStorage.setItem(DB_KEY, JSON.stringify(arr));
      }

      // ---------- camera stream state ----------
      let stream = null;
      openCamBtn.addEventListener("click", async () => {
        if (stream) {
          // already open => stop it
          stopCamera();
          return;
        }
        try {
          stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: "environment" },
            audio: false,
          });
          video.srcObject = stream;
          await video.play();
          // enable capture
          captureBtn.disabled = false;
          openCamBtn.textContent = "Close Camera";
          status("Camera open. Press Capture to take photo.");
          // we keep video hidden — capture uses video frames
        } catch (err) {
          status("Camera error: " + err.message);
          console.error(err);
        }
      });

      function stopCamera() {
        if (!stream) return;
        stream.getTracks().forEach((t) => t.stop());
        stream = null;
        captureBtn.disabled = true;
        openCamBtn.textContent = "Open Camera";
        status("Camera closed.");
      }

      // ---------- capture flow ----------
      // Offscreen canvas for high-resolution capture
      const offCanvas = document.createElement("canvas");
      const offCtx = offCanvas.getContext("2d");

      captureBtn.addEventListener("click", async () => {
        if (!stream) {
          status("Camera not open");
          return;
        }
        // capture current frame from video to offCanvas at native resolution
        const vw = video.videoWidth,
          vh = video.videoHeight;
        if (!vw || !vh) {
          status("Video not ready");
          return;
        }
        offCanvas.width = vw;
        offCanvas.height = vh;
        offCtx.drawImage(video, 0, 0, vw, vh);
        // convert to data URL and show as image
        const dataUrl = offCanvas.toDataURL("image/png");
        capturedImg.src = dataUrl;
        capturedImg.onload = () => {
          syncCanvasToImage();
          status(
            'Captured image displayed. Draw a box on the image then press "Crop & OCR".'
          );
          cropOcrBtn.disabled = false;
        };
        // stop camera after capture (one-shot)
        stopCamera();
      });

      // ---------- upload fallback ----------
      uploadFile.addEventListener("change", (e) => {
        const f = e.target.files[0];
        if (!f) return;
        const reader = new FileReader();
        reader.onload = () => {
          capturedImg.src = reader.result;
          capturedImg.onload = () => {
            syncCanvasToImage();
            status(
              'Uploaded image displayed. Draw a box then press "Crop & OCR".'
            );
            cropOcrBtn.disabled = false;
          };
        };
        reader.readAsDataURL(f);
      });

      // ---------- drawing selection ----------
      let drawing = false,
        startX = 0,
        startY = 0,
        sel = null;
      function syncCanvasToImage() {
        // size canvas to displayed image size
        drawCanvas.width = capturedImg.clientWidth;
        drawCanvas.height = capturedImg.clientHeight;
        drawCanvas.style.display = "block";
        drawCanvas
          .getContext("2d")
          .clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        sel = null;
      }

      // pointer events (work on desktop and mobile)
      drawCanvas.addEventListener("pointerdown", (ev) => {
        if (!capturedImg.src) return;
        drawing = true;
        const r = drawCanvas.getBoundingClientRect();
        startX = ev.clientX - r.left;
        startY = ev.clientY - r.top;
        sel = { x: startX, y: startY, w: 0, h: 0 };
      });
      drawCanvas.addEventListener("pointermove", (ev) => {
        if (!drawing || !sel) return;
        const r = drawCanvas.getBoundingClientRect();
        const x = ev.clientX - r.left,
          y = ev.clientY - r.top;
        sel.x = Math.min(startX, x);
        sel.y = Math.min(startY, y);
        sel.w = Math.abs(x - startX);
        sel.h = Math.abs(y - startY);
        drawSelection();
      });
      drawCanvas.addEventListener("pointerup", (ev) => {
        drawing = false;
        if (sel && sel.w > 4 && sel.h > 4)
          status("Region selected. Press Crop & OCR.");
        else {
          sel = null;
          drawSelection();
          status("Selection cleared");
        }
      });

      function drawSelection() {
        const ctx = drawCanvas.getContext("2d");
        ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
        if (sel) {
          ctx.strokeStyle = "rgba(255,80,80,0.95)";
          ctx.lineWidth = 3;
          ctx.strokeRect(sel.x, sel.y, sel.w, sel.h);
          ctx.fillStyle = "rgba(255,80,80,0.15)";
          ctx.fillRect(sel.x, sel.y, sel.w, sel.h);
        }
      }

      // ---------- crop & OCR ----------
      const { createWorker } = Tesseract;
      const worker = createWorker({
        logger: (m) => {
          /* optionally show m.status/m.progress */
        },
      });

      async function cropToBlobAndOCR() {
        if (!sel) {
          status("Draw a selection first");
          return;
        }
        // map selection from displayed image size back to the actual image pixel size (offCanvas)
        const img = capturedImg;
        // displayed sizes
        const displayW = img.clientWidth,
          displayH = img.clientHeight;
        // natural sizes (offCanvas capture or uploaded)
        // if we used capture from video, offCanvas has native capture resolution; else use image naturalWidth
        const naturalW = offCanvas.width || img.naturalWidth || img.width;
        const naturalH = offCanvas.height || img.naturalHeight || img.height;
        // compute scale
        const scaleX = naturalW / displayW;
        const scaleY = naturalH / displayH;
        const sx = Math.round(sel.x * scaleX);
        const sy = Math.round(sel.y * scaleY);
        const sw = Math.round(sel.w * scaleX);
        const sh = Math.round(sel.h * scaleY);
        if (sw <= 0 || sh <= 0) {
          status("Invalid crop");
          return;
        }

        // create temp canvas with crop region in natural pixel size
        const tmp = document.createElement("canvas");
        tmp.width = sw;
        tmp.height = sh;
        const tctx = tmp.getContext("2d");

        // If offCanvas has content (we captured via camera), draw from offCanvas, else draw from image natural
        if (offCanvas.width && offCanvas.height) {
          tctx.drawImage(offCanvas, sx, sy, sw, sh, 0, 0, sw, sh);
        } else {
          // draw from capturedImg (natural)
          tctx.drawImage(img, sx, sy, sw, sh, 0, 0, sw, sh);
        }

        // optional basic preprocessing: convert to grayscale + threshold
        const imgData = tctx.getImageData(0, 0, sw, sh);
        const d = imgData.data;
        for (let i = 0; i < d.length; i += 4) {
          const gray = Math.round(
            0.299 * d[i] + 0.587 * d[i + 1] + 0.114 * d[i + 2]
          );
          // simple thresholding
          const val = gray < 160 ? 0 : 255;
          d[i] = d[i + 1] = d[i + 2] = val;
        }
        tctx.putImageData(imgData, 0, 0);

        // toBlob and OCR
        status("Running OCR (this may take a few seconds)...");
        const blob = await new Promise((res) => tmp.toBlob(res, "image/png"));
        // show preview in captured image if desired
        // capturedImg.src = URL.createObjectURL(blob);

        await worker.load();
        await worker.loadLanguage("eng");
        await worker.initialize("eng");
        const { data } = await worker.recognize(blob);
        const text = data && data.text ? data.text.trim() : "";
        ocrResult.textContent = text;
        status("OCR done — edit or assign the text to a column then Save.");
      }

      cropOcrBtn.addEventListener("click", cropToBlobAndOCR);

      // ---------- assign & save ----------
      assignBtn.addEventListener("click", () => {
        const text = ocrResult.textContent.trim();
        if (!text) {
          status("No OCR text to assign");
          return;
        }
        const field = assignField.value;
        const rows = loadRows();
        // default new row with machine selected
        const newRow = {
          machine: machineSelect.value,
          downTime: "",
          reason: "",
          occurrence: "",
          operator: "",
        };
        newRow[field] = text;
        rows.push(newRow);
        saveRows(rows);
        renderRows();
        status("Assigned OCR text and saved row.");
        // clear selection / result
        sel = null;
        drawSelection();
        ocrResult.textContent = "";
      });

      // ---------- table UI ----------
      function renderRows() {
        const rows = loadRows();
        tbody.innerHTML = "";
        rows.forEach((r, idx) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `
        <td>${escapeHtml(r.machine)}</td>
        <td contenteditable="true" data-field="downTime">${escapeHtml(
          r.downTime
        )}</td>
        <td contenteditable="true" data-field="reason">${escapeHtml(
          r.reason
        )}</td>
        <td contenteditable="true" data-field="occurrence">${escapeHtml(
          r.occurrence
        )}</td>
        <td contenteditable="true" data-field="operator">${escapeHtml(
          r.operator
        )}</td>
        <td><button data-idx="${idx}" class="saveBtn">Save</button> <button data-idx="${idx}" class="delBtn">Delete</button></td>
      `;
          tbody.appendChild(tr);
        });
      }
      tbody.addEventListener("click", (e) => {
        if (e.target.classList.contains("saveBtn")) {
          const idx = Number(e.target.dataset.idx);
          const tr = e.target.closest("tr");
          const fields = tr.querySelectorAll("[contenteditable]");
          const rows = loadRows();
          rows[idx].downTime = fields[0].textContent.trim();
          rows[idx].reason = fields[1].textContent.trim();
          rows[idx].occurrence = fields[2].textContent.trim();
          rows[idx].operator = fields[3].textContent.trim();
          saveRows(rows);
          renderRows();
          status("Row saved.");
        } else if (e.target.classList.contains("delBtn")) {
          const idx = Number(e.target.dataset.idx);
          const rows = loadRows();
          rows.splice(idx, 1);
          saveRows(rows);
          renderRows();
          status("Row deleted.");
        }
      });

      downloadCsv.addEventListener("click", () => {
        const rows = loadRows();
        if (!rows.length) {
          status("No rows to download");
          return;
        }
        const hdr = [
          "Machine",
          "Down Time",
          "Reason",
          "Occurrence",
          "Operator",
        ];
        const csv = [hdr.join(",")]
          .concat(
            rows.map((r) =>
              [r.machine, r.downTime, r.reason, r.occurrence, r.operator]
                .map((v) => `"${(v || "").replace(/"/g, '""')}"`)
                .join(",")
            )
          )
          .join("\n");
        const blob = new Blob([csv], { type: "text/csv" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "downtime.csv";
        a.click();
        status("CSV downloaded.");
      });

      // small helpers
      function escapeHtml(s = "") {
        return (s + "").replace(
          /[&<>"']/g,
          (c) =>
            ({
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            }[c])
        );
      }
      function status(t) {
        statusEl.textContent = "Status: " + t;
      }
      // init
      renderRows();
    </script>
  </body>
</html>
